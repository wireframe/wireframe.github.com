---
layout: post
title: "Batch Javascript Execution"
date: 2009-11-25
comments: false
categories:
 - performance
 - javascript
---

<div class='post'>
Let's say you're in a bit of a mess with the performance of your fancy web application's Javascript.  Your application needs to do a lot of work on the front end.  I'm talking a <b>lot</b>&nbsp;of repetitive work that takes a <b>long</b>&nbsp;time.  Since Javascript is single threaded the end user's experience is pretty horrible.  Their web browser essentially "locks up" while you do all of your work and Firefox users will even be prompted with "Unresponsive script" alerts.  How are you going to optimize this?<br /><br />The "<b>correct</b>" answer is to either reduce the number of times you need to do the work, or to make each execution as fast as humanly possible.  Although that is a great suggestion, it's also potentially expensive and time consuming.  There comes a point of diminishing returns when you've fixed all the low-hanging fruit and you're only shaving off milliseconds with each change.  What if we could get a great user experience without going through all that work?  Well, now you can!<br /><br />The trick is to allow the browser to <b>breathe</b>&nbsp;between executions.  Executing your work in batches gives the browser time to re-draw and keeps the UI from locking up.  Although we're actually increasing the total execution time for doing your work due to the extra delays, the browser remains much more responsive and it greatly improves the end user experience.<br /><br />As an example, consider an application that is constructing a *huge* table via javascript.  (Let's ignore the fact that the unit of work is not optimized like it should be)<br /><pre>$.each(myHugeArray, appendTable);<br />function appendTable() &#123;<br />  $('&lt;tr&gt;&lt;td&gt;test&lt;/td&gt;&lt;/tr&gt;').appendTo($('#myTable'));<br />&#125;<br /></pre><br /><img src="http://farm4.static.flickr.com/3392/3578131663_c1a86da79d.jpg" /><br />This is your Javascript...<br /><br />Given enough iterations, this implementation will cause the browser to grind to a halt until the work is complete.  Instead of doing all the work at once, we can break it up into batches to help the end user experience.  Now, let's look at this solution that does the <b>exact same work</b>, just broken up into batches.<br /><pre>doInBatchesWithDelay(myHugeArray, appendTable, 5, 10);<br />function appendTable() &#123;<br />  $('&lt;tr&gt;&lt;td&gt;test&lt;/td&gt;&lt;/tr&gt;').appendTo($('#myTable'));<br />&#125;<br />function doInBatchesWithDelay(array, callback, batchSize, delay) &#123;<br />  for (var x = 0; x &lt; batchSize; x++) &#123;<br />    if (array.length &gt;0) &#123;<br />      callback(array.pop());<br />    &#125;<br />  &#125;<br />  if (array.length &gt; 0) &#123;<br />    setTimeout(function() &#123; <br />      doInBatchesWithDelay(array, callback, batchSize, delay) <br />    &#125;, delay);<br />  &#125;<br />&#125;<br /></pre><br /><a href="http://www.hulu.com/watch/17201/saturday-night-live-sloths"><img src="http://img.skitch.com/20091125-rp1sqth55am4iqmagethds2hx7.jpg" /></a><br />This is your Javascript in BATCHES!  It's still slow, but it'll kick your face in a punch fight!<br /><br />This might be considered a <b>hack</b>, but not so!  The end user experience is all that matters, and they have no concern for what tricks we have to use to keep the UI snappy.  The cost to profile and optimize applications is usually quite high and this is something you can easily drop in <b>today</b>&nbsp;and quiet the complaints of application sluggishness.  Addressing their problem with this small change will give you some headroom to work on rearchitecting your slow-ass implementation if needed.<br /><br />Now, go forth and batch!</div>
