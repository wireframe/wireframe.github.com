---
layout: post
title: "Wicket Autocomplete Text Field"
date: 2005-08-23
comments: false
categories:
 - javascript
 - java
 - scriptaculous
 - wicket
 - ajax
---

<div class='post'>
<p>Hold onto your seats boys and girls, this one entry you won't want to miss.</p><br /><br /><p>Anyone interested in building the next generation of web applications will hopefully have run across the <a href="http://script.aculo.us/demos/ajax/autocompleter_customized">amazing script.aculo.us demos</a>.  Wouldn't it be great to have these ajax components out of the box with our Java frameworks?  I mean, I've been impressed with <a href="http://www.rubyonrails.org/">Ruby on Rails</a>, but I can't see myself using it.  One of my gripes with Rails is the loss of previewable HTML.  Has anyone seen the <a href="http://script.aculo.us/demos/ajax/autocompleter_customized">source code for the demos</a>?  More importantly, can anyone understand them?  </p><br /><br /><p>Component frameworks like <a href="http://jakarta.apache.org/tapestry/">Tapestry</a> and <a href="http://wicket.sf.net">Wicket</a> allow for HTML designers to take complete control of the look and feel of website design, and dynamic content is plugged in without the need to learn <a href="http://jakarta.apache.org/velocity">new scripting languages</a> or use <a href="http://java.sun.com/products/jsp/jstl/">custom XML-ish tags</a>.  Or, does it seem a bit <i>too</i> logical to have HTML designers just use HTML when designing websites?  =)</p><br /><br /><p>I've been so impressed with Wicket and script.aculo.us, that I spent about 4 hours Friday night digging into the <a href="http://jroller.com/page/dashorst?entry=wicket_1_1_beta1_and">experimental ajax support in Wicket</a>.  My goal was to create a reusable autocomplete text field that would allow for <i>any</i> Wicket application to add the same functionality with a minimum amount of effort.</p><br /><br /><p>This example AutocompleteTextField is just an extention of the normal Wicket text field with some additional javascript and css output added.  This component is built using the same <a href="http://prototype.conio.net/">Prototype</a> javascript library that is used with Rails and scrit.aculo.us.  I had to really dig into the internals of Wicket in order to get this to work, so it may not be for the light of heart.  Hopefully someone smarter than I can figure out a more elegant approach to extending the Wicket render cycle.  This code may be a bit long, but I prefer giving the whole source instead of adding extra attachments.</p><br /><br /><pre><br />public class AutocompleteTextField extends TextField {<br />    private final AutocompleteEventHandler handler;<br /><br />    public AutocompleteTextField(String id, AutocompleteResultGenerator generator) {<br />        super(id);<br />        handler = new AutocompleteEventHandler(generator);<br />        add(handler);<br />    }<br /><br />    protected void onComponentTag(ComponentTag tag) {<br />        super.onComponentTag(tag);<br />        tag.put("id", getId());<br /><br />        //disable browser's autocompletion on this field<br />        tag.put("autocomplete", "off");<br />    }<br /><br />   /**<br />    * Prototype's Ajax.Autocompleter expects the autocomplete text field to have the following info:<br />    * &lt;input id="foo" /&gt;<br />    * &lt;div id="foo_autocomplete"&gt;&lt;/div&gt;<br />    */<br />    protected void onRender() {<br />        //render the text area<br />        super.onRender();<br /><br />        //print the hidden div area that the autocomplete results are rendered to<br />        String autocompleteId = getId() + "_autocomplete";<br />        final String url = this.urlFor(IEventRequestListener.class) + "&amp;id=" + handler.getId();<br />        getResponse().write("&lt;div class=\"auto_complete\" id=\"" + autocompleteId  + "\"&gt;&lt;/div&gt;");<br /><br />        //render javascript call to Prototype's Ajax.Autocompleter<br />        getResponse().write("&lt;script type=\"text/javascript\"&gt;new Ajax.Autocompleter('" + <br />            getId() + "', '" + autocompleteId + "', '" + url + "', {})&lt;/script&gt;");<br /><br />        //include a BASIC stylesheet for out-of-the box usability<br />        getResponse().write("&lt;style type=\"text/css\"&gt;\n" +<br />                "         div.auto_complete {\n" +<br />                "            width: 350px;\n" +<br />                "            background: #fff;\n" +<br />                "            overflow: hidden;\n" +<br />                "          }\n" +<br />                "          div.auto_complete ul {\n" +<br />                "            border:1px solid #888;\n" +<br />                "            margin:0;\n" +<br />                "            padding:0;\n" +<br />                "            width:100%;\n" +<br />                "            list-style-type:none;\n" +<br />                "          }\n" +<br />                "          div.auto_complete ul li {\n" +<br />                "            margin:0;\n" +<br />                "            padding:3px;\n" +<br />                "          }\n" +<br />                "          div.auto_complete ul li.selected {\n" +<br />                "            background-color: #ffb;\n" +<br />                "          }\n" +<br />                "          div.auto_complete ul strong.highlight {\n" +<br />                "            color: #800;\n" +<br />                "            margin:0;\n" +<br />                "            padding:0;\n" +<br />                "          }\n" +<br />                "&lt;/style&gt;\n" +<br />                "");<br />    }<br /><br />    private class AutocompleteEventHandler extends AbstractEventRequestHandler {<br />        private FormComponent formComponent;<br />        private final AutocompleteResultGenerator resultGenerator;<br /><br />        public AutocompleteEventHandler(AutocompleteResultGenerator resultGenerator) {<br />            this.resultGenerator = resultGenerator;<br />        }<br /><br />        public final void printHeadInitContribution(HtmlHeaderContainer container) {<br />            // add our basic javascript needs to the header<br />            //TODO: might not need to add all of these prototype scripts.<br />            addJsReference(container, new StaticResourceReference(AutocompleteTextField.class, "prototype.js"));<br />            addJsReference(container, new StaticResourceReference(AutocompleteTextField.class, "controls.js"));<br />            addJsReference(container, new StaticResourceReference(AutocompleteTextField.class, "dragdrop.js"));<br />            addJsReference(container, new StaticResourceReference(AutocompleteTextField.class, "effects.js"));<br />        }<br /><br />        private void addJsReference(HtmlHeaderContainer container, StaticResourceReference ref) {<br />            String url = container.getPage().urlFor(ref.getPath());<br />            String s =<br />                "\t&lt;script language=\"JavaScript\" type=\"text/javascript\" " +<br />                "src=\"" + url + "\"&gt;&lt;/script&gt;\n";<br />            write(container, s);<br />        }<br /><br />        private void write(HtmlHeaderContainer container, String s) {<br />            container.getResponse().write(s);<br />        }<br /><br />        public void bind(Component component) {<br />            if (!(component instanceof FormComponent)) {<br />                throw new IllegalArgumentException(<br />                        "this handler can only be bound to form components");<br />            }<br /><br />            if (formComponent != null) {<br />                throw new IllegalStateException(<br />                        "this kind of handler cannot be attached to "<br />                                + "multiple components; it is allready attached to component "<br />                                + formComponent + ", but component "<br />                                + component + " wants to be attached too");<br /><br />            }<br /><br />            this.formComponent = (FormComponent) component;<br />        }<br /><br />        public void onComponentTag(Component component, ComponentTag tag) {<br />        }<br /><br />        protected IResourceStream getResponse() {<br />            StringBufferResourceStream s = new StringBufferResourceStream();<br /><br />            formComponent.validate();<br />            if (formComponent.isValid()) {<br />                formComponent.updateModel();<br />            }<br />            String value = formComponent.getValue();<br /><br />            //render results in list<br />            //prototype's Ajax.Autocompleter automatically places results into the hidden div area<br />            s.append("&lt;ul&gt;\n");<br />            String[] results = resultGenerator.getResults(value);<br />            for (int x = 0; x &lt; results.length; x++) {<br />                String result = results[x];<br />                s.append("&lt;li class=\"contact\"&gt;" + result + "&lt;/li&gt;\n");<br />            }<br />            s.append("&lt;/ul&gt;\n");<br /><br />            return s;<br />        }<br />    }<br />}<br /></pre><br /><br /><p>Developers can now get this sweet autocomplete text field in the application.  Notice how the HTML template is <i>exactly</i> the same.  The template has no idea of the underlying autocomplete/ajax functionality.</p><br /><pre><br />&lt;html xmlns:wicket="http://wicket.sourceforge.net/"&gt;<br />&lt;body&gt;<br />&lt;form wicket:id="searchForm"&gt;<br />  Search:<br />  &lt;input wicket:id="query" type="text"/&gt;<br />  &lt;input wicket:id="submitButton" type="submit" value="Submit"/&gt;<br />&lt;form&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;<br /></pre><br /><br /><p>It's the job of the Java form to add the new AutocompleteTextField and to register the AutocompleteResultGenerator.  This example uses a hard coded list of results, but it can easily be customized to perform any custom search or lookup of information.</p><br /><pre><br />public class SearchForm extends Form {<br />    public SearchForm(String id, IFeedback feedback) {<br />        super(id, new CompoundPropertyModel(new SearchModel()), feedback);<br /><br />        AutocompleteResultGenerator searcher = new AutocompleteResultGenerator() {<br />            public String[] getResults(String input) {<br />                return new String[] {"Bob", "Jamie", "Eric"};<br />            }<br />        };<br /><br />        add(new AutocompleteTextField("query", searcher));<br />        add(new Button("submitButton"));<br />    }<br /><br />    protected void onSubmit() {<br />        //do something with the search text<br />    }<br />}<br /></pre><br /><br /><p>There's plenty of room for improvement, but I hope that this will serve as a springboard for others trying out the already impressive Wicket ajax support.  It would be great to enhance API to be more Wicket friendly like returning a ListView instead of a String[].  Hopefully with a little support, this component could work it's way into wicket for other developers to use.  </p><br /><br /><p>And to all those <a href="http://jroller.com/page/wireframe/?anchor=web_development_done_right">insightful comments on my last blog</a> saying that JSP was "good enough" for a web technology, let's see JSP do this!  And don't you <i>dare</i> mention JSF...</p></div>
