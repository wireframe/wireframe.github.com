---
layout: post
title: "Ruby Syntax For Java Maps"
date: 2006-06-06
comments: false
categories:
 - ruby
 - java
---

<div class='post'>
<p>Ruby's got a lot of momentum going for it right now.  One of the syntax sugars that has gotten a lot of attention is for <a href="http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html#hash">creation of maps</a>.  Compare the typical Java code to create a map with the Ruby equivilent, and you'll see why it's getting so much attention.</p><br /><br /><pre><br />//Java implementation<br />Map options = new HashMap();<br />options.put("foo", "bar");<br />options.put("option", "value");<br />options.put("flag", "true");<br /><br />//Ruby implementation<br />&#123;"foo"=>"bar", "option"=>"value", "flag"=>"true"&#125;<br /></pre><br /><br /><p>This ease of use has led to the creation of several Ruby API's that take a map as a parameter.  Javascript developers have been doing this for quite some time, and <a href="http://script.aculo.us/">scriptaculous</a> is an excellent example of how to use a map parameter effecively to pass optional information.  </p><br /><br /><p>Ruby and Javascript have essentially taken maps and used them as named parameters, which has led to <i>many</i> Java developers clammering for <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4124331">first class named parameter support in Java</a>.  It isn't necessary to "fix" Java to support this feature, because this can be accomplished already with no JVM changes.  To put it bluntly, Java has the ability to make maps more usable, it's just a bit different than Ruby.</p><br /><br /><p>This slick little example is just leveraging a little known Java feature called an initializing block.  Basically, it's creating a subclass of the desired map implementation, and initializing the map upon construction.  This code will work for any kind of map.</p><br /><pre><br />Map options = new HashMap() &#123;&#123; <br />  put("key", "value"); <br />  put("option", "foo"); <br />  put("flag", "bar"); <br />&#125;&#125;;<br /></pre><br /><br /><p>Another way to accomplish this would be to create a utility implementation that takes a multi-dimensional array as a constructor argument.  The downfall of this implementation is that you can't swap out implementations as easily.  This would be an issue if you're using something like the <a href="http://jakarta.apache.org/commons/collections">commons-collections</a> map implementations.</p><br /><pre><br />Map options = new SimpleHashMap(new Object[][] &#123;<br />  &#123;"key", "value"&#125;, <br />  &#123;"option", "foo"&#125;,<br />  &#123;"flag", "bar"&#125;<br />&#125;);<br /><br />//simple implementation of the helper class<br />public class SimpleHashMap extends HashMap &#123;<br /><br />  public SimpleHashMap(Object[][] options) &#123;<br />    for (int x = 0; x < options.length; x++) &#123;<br />      Object key = options[x][0];<br />      Object value = options[x][1];<br /><br />      put(key, value);<br />    &#125;<br />  &#125;<br />&#125;<br /></pre><br /><br /><p>Maybe the Ruby syntax sugar would be <i>nice</i> for Java, but it certainly is not necessary.  As a side note, it's essential that developers take <i>extreme</i> care when developing API's that use map parameters.  An API needs to have <a href="http://jroller.com/page/wireframe?entry=clear_api">clear expectations</a> for what it needs to perform it's work.  The concept of passing a map to a method only makes sense when the map contains <i>optional</i> flags.  It's all about sensible defaults, and the successful Javascript and Ruby API's have got that down.  If a method takes a map of options, it better work just fine with an empty map!  </p><br /><br /><!-- technorati tags begin --><br /><p style="font-size: 10px; text-align: right;">technorati tags: <br /><a href="http://technorati.com/tag/java" rel="tag">java</a>, <br /><a href="http://technorati.com/tag/ruby" rel="tag">ruby</a><br /></p><br /><!-- technorati tags end --></div>
