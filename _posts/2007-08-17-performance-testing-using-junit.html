---
layout: post
title: "Performance Testing using JUnit"
date: 2007-08-17
comments: false
categories:
 - performance
 - java
 - testing
---

<div class='post'>
<p>I've been heavily involved with a major performance initiative for the past several months.  One thing I have constantly found frustrating is how few <i>good</i> tools exist for this type of work.  Specifically, I have yet to run across a good Java library for programatically measuring performance metrics.</p><br /><br /><p>You may be quick to try and point me to <a href="http://clarkware.com/software/JUnitPerf.html">JUnitPerf</a>, but let me stop you right there and tell you that JUnitPerf is utter crap.  It is simply a cobbled together set of incoherent API's that are more effort than their worth.  They had the <i>right idea</i>, but their end product is rubbish.</p><br /><br /><p>What do I have that's any better?  Let's start with this as our base class:</p><br /><pre><br />public class PerformanceTestCase extends TestCase {<br />  protected void assertFasterThan(long millis, Runnable runnable) {<br />    long start = System.currentTimeMillis();<br />    runnable.run();<br />    long executionTime = System.currentTimeMillis() - start;<br /><br />    assertTrue("Expected execution time to be less than " + millis + " but was " + executionTime, executionTime &lt;= millis);<br />  }<br />}<br /></pre><br /><br /><p>Using this little base class, I can start to write a <i>real</i> performance test using a standard JUnit API like so:</p><br /><pre><br />public class MyObjectTestCase extends PerformanceTestCase {<br />  public void testMyOperationIsFasterThanTheSpeedOfLight() {<br />    //perform setup here<br />    final MyObject object = new MyObject();<br />    Runnable work = new Runnable() {<br />      public void run() {<br />        //do work that should be measured here<br />        object.doStuff();<br />      }<br />    };<br /><br />    assertFasterThan(10, work);<br />  }<br />}<br /></pre><br /><br /><p>Using <code>assertFasterThan</code> is a good start, but anyone who's done <i>real</i> performance testing knows that there are <i>lots</i> of factors that cause fluctuations in the execution speed of code.  This is <i>especially</i> true when your building integration tests that interact with databases or other resources.  To get a more reliable metric, we need to execute the same block of code multiple times and grab the average.  Here's an new method to perform just that.</p><br /><pre><br />protected void assertAverageFasterThan(long millis, Runnable runnable, int numberOfExecutions) {<br />  long start = System.currentTimeMillis();<br />  for (int x = 0; x &lt; numberOfExecutions; x++) {<br />    runnable.run();<br />  }<br />  long executionTime = System.currentTimeMillis() - start;<br />  long average = executionTime / numberOfExecutions;<br /><br />  assertTrue("Expected average execution time to be less than " + millis + " but was " + average, average &lt;= millis);<br />}<br /></pre><br /><br /><p>Now, I can execute my code a number of times to make sure that one slow (or fast) execution doesn't skew my results.</p><br /><pre><br />public class MyObjectTestCase extends PerformanceTestCase {<br />  public void testMyOperationIsFasterThanTheSpeedOfLight() {<br />    //perform setup here<br />    final MyObject object = new MyObject();<br />    Runnable work = new Runnable() {<br />      public void run() {<br />        //do work that should be measured here<br />        object.doStuff();<br />      }<br />    };<br /><br />    //execute the block of code 100 times and take the average<br />    assertAverageFasterThan(10, work, 100);<br />  }<br />}<br /></pre><br /><br /><p>Before I finish, let me remind everyone:<br /><br /><a href="http://www.jroller.com/wireframe/entry/performance_is_overrated">Early optimization is the root of much evil.</a></p><br /><br /><p>These tools and techniques should be used sparingly and <b>only</b> under the supervision of a licensed therapist.  =)</p></pre></pre></div>
