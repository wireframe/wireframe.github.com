---
layout: post
title: "Simple Hibernate Search Engine"
date: 2005-08-17
comments: false
categories:
 - java
 - shard
 - search
 - database
---

<div class='post'>
<p>Wouldn't it be great to be able to use a powerful search engine on your business objects?  Searching is becoming <i>THE</i> preferred way for user's to find their data.  Emerging applications like <a href="http://desktop.google.com">Google Desktop</a> and <a href="http://beaglewiki.org/Main_Page">Beagle</a> have embraced the new mantra of user's to <i>"Search, Don't Sort"</i>.  User's don't want to be forced to organize their data into limiting categories or folders, or to scroll around applications to find the data they are looking for.  Even common GUI practices like table sorting are considered an eye sore compared to a snappy search box.</p><br /><br /><p>I have experienced the same expectation when working with my D20 datasets.  It's become increasingly difficult to manage lists of skills, feats and items across multiple sources.  To try and improve the user experience, I have <a href="http://jira.codecrate.com/browse/SHA-84">integrated a full blown search engine</a> into <a href="http://shard.codecrate.com">shard</a>.</p><br /><br /><p>My goal was create a simple search framework to handle simple searching for the majority of my domain objects out of the box.  I wanted all of my objects to be placed into the same index, and my search to be smart enough to know what object's I want returned.  Something that made the client API as simple as:</p><br /><br /><pre><br />Collection results = searcher.search(DefaultSkill.class, "knowledge arc*");<br /></pre><br /><br /><p>In order for the searcher to be smart enough to know what type of objects to search and what type of objects to return from Hibernate, the datatype and the unique Hibernate key need to exist in the index.</p><br /><br /><table><br />  <tr><br />    <th>Object</th><br />    <th>Id</th><br />    <th>Text</th><br />  <tr><br />  <tr><br />    <td>foo.bar.MyObject</td><br />    <td>123</td><br />    <td>Happy Dog</td><br />  </tr><br />  <tr><br />    <td>foo.bar.YourObject</td><br />    <td>456</td><br />    <td>Yellow Puppy</td><br />  </tr><br /></table><br /><br /><p>The first piece of the puzzle was to figure out how to create an index with my persistent objects.  I found that the Hibernate Interceptor provided an excellent entry point for indexing my objects.  It was actually pretty simple to implement.</p><br /><br /><pre class="code"><br />public class LuceneInterceptor implements Interceptor {<br />    private static final Log LOG = LogFactory.getLog(LuceneInterceptor.class);<br />    private static final boolean DO_NOT_CREATE_INDEX = false;<br /><br />    private final Directory directory;<br />    private final Analyzer analyzer;<br /><br />    public LuceneInterceptor(DirectoryManager directoryManager) {<br />        this.directory = directoryManager.getDirectory();<br />        this.analyzer = new StandardAnalyzer();<br />    }<br /><br />    public boolean onSave(Object entity, Serializable id,<br />            Object[] currentState, String[] propertyNames, Type[] types)<br />            throws CallbackException {<br /><br />        //this call cleans out any existing document in the index<br />        removeDocuments(id);<br /><br />        IndexWriter writer = null;<br />        try {<br />            writer = new IndexWriter(directory, analyzer, DO_NOT_CREATE_INDEX);<br />            Document document = new Document();<br />            document.add(Field.Keyword(LuceneSearcher.FIELD_CLASS, entity.getClass().getName()));<br />            document.add(Field.Keyword(LuceneSearcher.FIELD_ID, id.toString()));<br /><br />            //This is a VERY simplistic way to index data about the entity<br />            //ideally you would have some kind of extension point to allow for more detailed<br />            //information to be extracted about the entity based on the datatype<br />            document.add(Field.Text(LuceneSearcher.FIELD_TEXT, entity.toString()));<br /><br />            LOG.info("saving " + document);<br />            writer.addDocument(document);<br />        } catch (IOException e) {<br />            LOG.error("Error updating index for object " + entity, e);<br />        } finally {<br />            closeWriter(writer);<br />        }<br /><br />        return false;<br />    }<br /><br />    public void onDelete(Object entity, Serializable id, Object[] state,<br />            String[] propertyNames, Type[] types) {<br />        removeDocuments(id);<br />    }<br /><br />    private void removeDocuments(Serializable id) {<br />        IndexReader reader = null;<br />        try {<br />            reader = IndexReader.open(directory);<br />            int numDeleted = reader.delete(new Term("id", id.toString()));<br />            if (0 < numDeleted) {<br />                LOG.info("Removed " + numDeleted + " documents from index " + directory);<br />            }<br />        } catch (IOException e) {<br />            LOG.error("Error removing documents for " + id + " from index " + directory, e);<br />        } finally {<br />            closeReader(reader);<br />        }<br />    }<br /><br />    private void closeWriter(IndexWriter writer) {<br />        if (null != writer) {<br />            try {<br />                writer.close();<br />            } catch (IOException e) {<br />                LOG.warn("Error while closing index writer", e);<br />            }<br />        }<br />    }<br /><br />    private void closeReader(IndexReader reader) {<br />        if (null != reader) {<br />            try {<br />                reader.close();<br />            } catch (IOException e) {<br />                LOG.warn("Error closing index reader for index " + directory, e);<br />            }<br />        }<br />    }<br /><br />    // ommitted other interceptor methods<br /><br />}<br /></pre><br /><br /><p>Next up was creating the simple/smart searcher which is responsible for performing the lucene search and looking up the records in Hibernate.</p><br /><br /><pre class="code"><br /><br />public class LuceneSearcher extends HibernateTemplate {<br />    public static final String FIELD_CLASS = "class";<br />    public static final String FIELD_TEXT = "text";<br />    public static final String FIELD_ID = "id";<br /><br />    private static final Log LOG = LogFactory.getLog(LuceneSearcher.class);<br />    private static final boolean REQUIRED = true;<br />    private static final boolean NOT_PROHIBITED = false;<br /><br />    private final Directory directory;<br />    private final Analyzer analyzer;<br /><br />    public LuceneSearcher(DirectoryManager directoryManager) {<br />        this.directory = directoryManager.getDirectory();<br />        this.analyzer = new StandardAnalyzer();<br />    }<br /><br />    public Collection search(Class target, String query) {<br />        Searcher searcher = null;<br />        Collection results = new ArrayList();<br /><br />        try {<br />            searcher = new IndexSearcher(directory);<br />            BooleanQuery masterQuery = new BooleanQuery();<br />            masterQuery.add(new TermQuery(new Term(FIELD_CLASS, target.getName())), REQUIRED, NOT_PROHIBITED);<br />            masterQuery.add(QueryParser.parse(makeWildcardQuery(query), FIELD_TEXT, analyzer), REQUIRED, NOT_PROHIBITED);<br /><br />            LOG.info("Searching for " + masterQuery);<br /><br />            Hits hits = searcher.search(masterQuery);<br />            LOG.info("Found " + hits.length() + " matches");<br />            for (int x = 0; x < hits.length(); x++) {<br />                Document document = hits.doc(x);<br />                String id = document.getField(FIELD_ID).stringValue();<br /> <br />                //lookup the object from hibernate<br />                Object result = this.get(target, id);<br />                if (null == result) {<br />                    LOG.warn("Search index is out of synch with database.  Unable to find object " + target + " with id " + id);<br />                } else {<br />                    results.add(result);<br />                }<br />            }<br /><br />        } catch (Exception e) {<br />            LOG.error("Error searching directory " + directory + " for type " + target + " using query " + query, e);<br />        } finally {<br />            closeSearcher(searcher);<br />        }<br /><br />        return results;<br />    }<br /><br />    private String makeWildcardQuery(String query) {<br />        String result = query.trim();<br />        if (0 != result.length()) {<br />            if (!result.endsWith("*")) {<br />                result = result + "*";<br />            }<br />        }<br />        return result;<br />    }<br /><br />    private void closeSearcher(Searcher searcher) {<br />        if (null != searcher) {<br />            try {<br />                searcher.close();<br />            } catch (IOException e) {<br />                LOG.warn("Error closing searcher", e);<br />            }<br />        }<br />    }<br />}<br /></pre><br /><br /><p>This solution works like a charm, and is easily extensible for future improvements.  You can check it out in action by <a href="http://www.codecrate.com/display/SHA/Home">launching the shard-phoenix data management application</a>.  Complete source code can be found in the <a href="https://shard.dev.java.net/source/browse/shard/shard-hibernate/">shard-hibernate subproject</a>.</p></div>
