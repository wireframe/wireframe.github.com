---
layout: post
title: "Spring Rich Event Processing Bus"
date: 2006-07-12
comments: false
categories:
 - performance
 - java
 - spring
 - springrcp
---

<div class='post'>
<p>For the past few weeks I've been working with spring rich to try and build a simple solution for performing units of work within the gui framework, but so far, <a href="http://jroller.com/page/wireframe/?anchor=crazy_command_composition">my solution has been anything but simple</a>.</p><br /><br /><p>I started becoming very interested in this area after reading <a href="http://www.ditchnet.org/wp/2005/06/05/remedial-spring-rcp-episode-2-targetableactioncommands-and-the-edt/">a blog on how Spring could be more tightly integrated with Swing for thread management</a>.  Container managed threading, essentially.  I've taken a lot of inspiration from that blog, and have formed it into something that's actually usable.</p><br /><br /><p>The solution I've come up with leverages the <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#context-functionality-events">spring application event framework</a> to fire processing of these GUI specific actions.  I call it an <strong>Event Processing Bus</strong>.  Here are a few specific use cases that my current solution supports:</p><br /><br /><ul><br />  <li>Perform long running operation in a background thread.</li><br />  <li>Prevent UI from locking up while operation is being performed.</li><br />  <li>Provide user feedback for progress of operation.</li><br />  <li>Prevent user input until operation is complete.</li><br /></ul><br /><br /><p>For starters, I did not want to couple my business layer to Spring.  Heck, I didn't even want to implement the Spring <code>ApplicationListener</code> interface.  I just wanted a simple POJO that would perform work on a published event.</p><br /><br /><pre><br />public class MyService {<br />  public void processApplicationEvent(MyEvent event) {<br />    //perform operation with event<br />    Thread.sleep(1000);  //just for fun <br />  }<br />}<br /></pre><br /><br /><p>Wiring this object in Spring is now <em>much</em> simpler than <a href="http://jroller.com/page/wireframe/?anchor=crazy_command_composition">my previous incarnation</a>.  Simply wrap your business object in the <code>EventTriggeredProgressMonitoredBackgroundCommandExecutor</code> and tell it what method to invoke.  It'll take care of the rest!</p><br /><br /><pre><br />&lt;bean id="myService"<br /> class="org.myproject.MyService"&gt;<br />&lt;/bean&gt;<br /><br />&lt;bean id="myCommand"<br /> class="com.codecrate.shard.ui.command.EventTriggeredProgressMonitoredBackgroundCommandExecutor"&gt;<br />  &lt;constructor-arg&gt;&lt;value&gt;org.myproject.MyEvent&lt;/value&gt;&lt;/constructor-arg&gt;<br />  &lt;constructor-arg index="1"&gt;&lt;ref bean="myService"/&gt;&lt;/constructor-arg&gt;<br />  &lt;constructor-arg index="2"&gt;&lt;value&gt;processApplicationEvent&lt;/value&gt;&lt;/constructor-arg&gt;<br />&lt;/bean&gt;<br /></pre><br /><br /><p>Thus far, I haven't shown any details on how this helps Spring Rich GUI applications.  It has just been using the core spring framework to wrap event processing in background threads.  But this solution really shines when you want to change your service to provide user feedback.  Simply update your service to take a Spring Rich <code>ProgressMonitor</code>, and without updating any configuration files, your service will be invoked correctly.</p><br /><br /><pre><br />public class MyService {<br />  public void processApplicationEvent(MyEvent event, ProgressMonitor progressMonitor) {<br />    //perform operation with event<br />  }<br />}<br /></pre><br /><br /><p>Here is where my solution really differentiates from a simple <em>background thread event processer</em>.  The <code>EventTriggeredProgressMonitoredBackgroundCommandExecutor</code> doesn't simply pass the application event to the target object, it allows for more information to be placed in the context so that the target object can have access to that information as well.</p><br /><br /><p>I'd like to invest some more time to see if I can invoke operations without always blocking user input.  Blocking user input is definately the "safest" solution, but it would be nice to execute operations in the background and allow the user to continue working.</p><br /><br /><!-- technorati tags begin --><br /><p style="font-size: 10px; text-align: right;">technorati tags: <br /><a href="http://technorati.com/tag/java" rel="tag">java</a>, <br /><a href="http://technorati.com/tag/swing" rel="tag">swing</a>, <br /><a href="http://technorati.com/tag/spring" rel="tag">spring</a>, <br /><a href="http://technorati.com/tag/rcp" rel="tag">rcp</a><br /></p><br /><!-- technorati tags end --></div>
