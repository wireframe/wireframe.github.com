---
layout: post
title: "BeanPropertyTableModel"
date: 2004-10-05
comments: false
categories:
 - java
---

<div class='post'>
<p>I finally have seen the light for how powerful reflection can be.  I used to painstakingly create a seperate table model for each of my java objects that I wanted to display in a table.  Each class had a custom case/switch statement to return the correct value for the requested column.</p><br /><p>In short, it was inelegant but it worked.  Now, I've put together a table model for <a href="https://riva.dev.java.net">riva</a> that uses <a href="http://jakarta.apache.org/commons">commons-beanutils</a> to introspect a beans properties to return the correct value.  It handles setting values as well, and will only set a column as editable if the object has a setter method for that property.<br /></p><br /><br /><pre><br />//here was my old way of doing table models.<br />//each class had a custom table model.<br />public class MyObjectTableModel &#123;<br />    private List objects = new ArrayList();<br /><br />    //ommitted unimportant methods<br /><br />    public void addObject(Object myObject) &#123;<br />        objects.add(myObject);<br />    &#125;<br /><br />    public Object getObject(int row) &#123;<br />       return objects.get(row);<br />    &#125;<br /><br />    public Object getValueAt(int row, int column) &#123;<br />        MyObject object = (MyObject) getObject(row);<br />        Object value = null;<br /><br />        switch(column) &#123;<br />            case 0:<br />            value = object.getMyField1();<br />            break;<br />            <br />            case 1:<br />            value = object.getMyField2();<br />            break;<br />        &#125;<br />        return value;<br />    &#125;<br />&#125;<br /></pre><br /><br /><p>You can see the new table by checking the <a href="https://riva.dev.java.net/source/browse/riva/riva-core/src/java/com/codecrate/riva/model/BeanPropertyTableModel.java">riva cvs file</a>.</p></div>
