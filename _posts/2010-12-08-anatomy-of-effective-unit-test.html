---
layout: post
title: "Anatomy of an Effective Unit Test"
date: 2010-12-08
comments: false
categories:
 - testing
---

<div class='post'>
<a href="http://1.bp.blogspot.com/_yocpuDtbm4c/TQBR1QacfVI/AAAAAAAAABU/FqFtno1aIbE/s1600/doogietest.png"><img border="0" height="400" src="http://1.bp.blogspot.com/_yocpuDtbm4c/TQBR1QacfVI/AAAAAAAAABU/FqFtno1aIbE/s400/doogietest.png" width="382" /></a><br /><br />Writing an effective and expressive unit test is just as important as writing clean application code.  Unfortunately, there are not nearly enough resources for <b>how</b>&nbsp;to write good unit tests. <br /><br />Dr. Sonnek is in the house today with a prescription. &nbsp;Let's start by defining the "<b>Anatomy of an Effective Unit Test</b>".<br /><br />Every single unit test should be composed of 4 parts: <b>Description, Setup, Execution, Assertion</b>. <br /><br />To be perfectly clear, I'm <i>not</i> encouraging writing complex unit tests in any way, shape or form. &nbsp;These 4 aspects of a unit test can, and should be, fulfilled in as few as 5 lines of code. &nbsp;Each testing library will have a slightly different feel, but the majority of old school testing frameworks rely on procedural execution or conventions to express these rules (JUnit, JSUnit, TestUnit, etc).<br /><pre>#this is teh old school way to write tests<br />#test description<br />def test_creating_blog_sends_email<br />  #setup<br />  user = User.create!<br /><br />  #execute<br />  blog = user.blogs.create!<br /><br />  #assert<br />  assert Mail.sent?<br />end<br /></pre><br />Several <i>modern</i> testing frameworks have introduced a clearer separation between these important aspects and use structural separation between setup/execution and assertion which makes it easier to scan tests and read what they are trying to accomplish.  Here's a basic example, and I'll break down each section afterwards.<br /><br /><pre>#this is teh new hotness for writing tests<br />#describe the execution context (data, environment, etc)<br />context "creating blog post with new user" do<br />  setup do<br />    #setup<br />    user = User.create!<br /><br />    #execute<br />    blog = user.blogs.create!<br />  end<br />  #assert<br />  should 'send email to author' do<br />    assert Mail.sent?<br />  end<br />end<br /></pre><br />I'll use shoulda syntax for these examples, but the same principles apply to RSpec, JSspec, etc. &nbsp;Now, let's dive into the Anatomy of an Effective Unit Test...<br /><br /><h3>Description</h3>Separating the setup/execution/assertions into separate blocks creates self documenting and highly readable tests. &nbsp;The "description" component for each part of your test (setup, execute, assertion) is used to construct a sentence for your test. &nbsp;This is a welcome change from the uglified test naming convention used by legacy test frameworks.  The previous example would read:<br /><b>"creating blog post with new user should send email to author"</b><br /><br /><h3>Setup</h3>Test setup is used to initialize environmental or data dependencies before execution and assertion. &nbsp;The description for your setup block should clearly describe these dependencies.<br /><pre>context "with new user" do<br />  setup do<br />    @user = User.new<br />  end<br />end<br /></pre><br /><h3>Execute</h3>Execution is just another <i>form</i> of setup, and lives alongside other environmental or data setup. &nbsp;The description for your execution context should match the method you are invoking and what parameters are being used for this particular invocation.<br /><pre>context "creating blog" do<br />  setup do<br />    blog = @user.blogs.create!<br />  end<br />end<br /></pre><br /><h3>Assert</h3>One assertion per test.  No more...no less. Old school unit tests very commonly have multiple assertions per test but Shoulda makes it <b>super </b>simple&nbsp;to encapsulate each assertion and re-use common setup/execution contexts.<br /><pre>should 'send email to author' do<br />  assert Mail.sent?<br />end<br /></pre><br />Writing effective unit tests is never easy, but structuring your unit tests correctly and understanding the importance of each aspect should make your job just a little bit easier.</div>
